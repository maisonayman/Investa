import json
from django.http import JsonResponse, HttpResponseBadRequest
from Investa.utils import send_otp_email, upload_video_to_drive, send_password_reset_email_custom, upload_image_to_drive, get_or_create_drive_folder
from django.core.cache import cache
from firebase_admin import auth, db
from rest_framework.response import Response
from rest_framework.decorators import api_view, parser_classes
from rest_framework.parsers import MultiPartParser, FormParser
import os
import uuid
from rest_framework import status
from django.conf import settings
import requests
from rest_framework.views import APIView




@api_view(['POST'])
def request_otp(request):
    """Send OTP and temporarily store user details using Firebase-generated ID."""
    try:
        data = json.loads(request.body)
        email = data.get("email")
        password = data.get("password")
        username = data.get("username")
        dob = data.get("date_of_birth")

        if not email or not password:
            return JsonResponse({"error": "Email and Password are required"}, status=400)

        # Check if email already exists
        users_ref = db.reference("users")
        existing_users = users_ref.order_by_child("email").equal_to(email).get()
        if existing_users:
            return JsonResponse({"error": "Email already exists"}, status=400)

        # Send OTP
        send_otp_email(email)

        # Generate a new Firebase user ID for temporary storage
        temp_user_ref = users_ref.push({})
        temp_user_id = temp_user_ref.key

        # Cache user details for OTP verification
        user_data = {
            "firebase_user_id": temp_user_id,
            "email": email,
            "password": password,
            "username": username,
            "date_of_birth": dob
        }
        cache.set(f"user_data_{email}", user_data, timeout=600)

        return JsonResponse({"message": "OTP sent to email"}, status=200)

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)
    
    
@api_view(['POST'])
def verify_otp(request):
    """Verify OTP and create user after successful verification (no profile picture)."""
    if request.method != "POST":
        return JsonResponse({"error": "Invalid request"}, status=405)

    try:
        if not request.content_type.startswith("multipart/form-data"):
            return JsonResponse({"error": "Request content-type must be multipart/form-data"}, status=402)

        email = request.POST.get("email")
        otp_entered = request.POST.get("otp")

        stored_otp = cache.get(email)
        if not stored_otp or stored_otp != otp_entered:
            return JsonResponse({"error": "Invalid or expired OTP"}, status=403)

        cache.delete(email)  # OTP is used, delete it

        # Retrieve stored user data
        user_data = cache.get(f"user_data_{email}")
        if not user_data:
            return JsonResponse({"error": "User data expired. Please sign up again."}, status=404)

        # Create user in Firebase Authentication
        user = auth.create_user(
            email=user_data["email"],
            password=user_data["password"],
            display_name=user_data["username"]
        )

        # Use the UID generated by Firebase Auth
        firebase_user_id = user.uid

        # Save user details in Firebase Realtime Database
        users_ref = db.reference("users")
        user_info = {
            "email": user_data["email"],
            "username": user_data["username"],
            "date_of_birth": user_data["date_of_birth"]
        }
        users_ref.child(firebase_user_id).set(user_info)

        # Clear cache
        cache.delete(f"user_data_{email}")

        return JsonResponse({
            "message": "Account created successfully",
            "user_id": firebase_user_id
        }, status=201)

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)


@api_view(['POST'])
def sign_in(request):
    try:
        data = json.loads(request.body)
        email = data.get("email")
        password = data.get("password")

        if not email or not password:
            return JsonResponse({"message": "Missing email or password"}, status=400)

        # Firebase REST API endpoint for sign in
        url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={settings.FIREBASE_WEB_API_KEY}"

        payload = {
            "email": email,
            "password": password,
            "returnSecureToken": True
        }

        response = requests.post(url, json=payload)
        result = response.json()

        if "error" in result:
            return JsonResponse({"message": result["error"]["message"]}, status=401)

        user_id = result["localId"]
        id_token = result["idToken"]

        # Get user data from Realtime Database
        db_url = f"{settings.FIREBASE_DB_URL}/users/{user_id}.json?auth={id_token}"
        user_response = requests.get(db_url)
        user_data = user_response.json()

        if user_data is None:
            return JsonResponse({
                "message": "Sign-in successful, but user details not found in database.",
                "idToken": id_token,
                "refreshToken": result["refreshToken"],
                "user_id": user_id,
                "email": result["email"]
            })

        return JsonResponse({
            "message": "Sign-in successful",
            "idToken": id_token,
            "refreshToken": result["refreshToken"],
            "user_id": user_id,
            "email": result["email"],
            "date_of_birth": user_data.get("date_of_birth"),
            "username": user_data.get("username")
        })

    except Exception as e:
        return JsonResponse({"message": f"Error: {str(e)}"}, status=500)

class PersonalDataList(APIView):
    def get(self, request):
        ref = db.reference("users")
        data = ref.get()
        return Response(data if data else {}, status=status.HTTP_200_OK)

    def post(self, request):
        try:
            body = request.data
            user_id = body.get('user_id')
            if not user_id:
                return Response({'error': 'User ID is required'}, status=status.HTTP_400_BAD_REQUEST)

            # الإشارة لبيانات المستخدم داخل جدول users
            ref = db.reference("users").child(user_id)

            # تحديث فقط بدون مسح باقي البيانات
            ref.update({
                'full_name': body.get('full_name', '').strip(),
                'national_id': body.get('national_number', '').strip(),
                'phone_number': body.get('phone_number', '').strip(),
                'birthdate': body.get('birthdate', '2000-01-01').strip(),
                'country': body.get('country', '').strip(),
                'postal_code': body.get('postal_code', '').strip(),
                'address_1': body.get('address_1', '').strip(),
                'address_2': body.get('address_2', '').strip(),
            })

            return Response({'message': 'Personal data updated successfully'}, status=status.HTTP_201_CREATED)

        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


class PersonalDataDetail(APIView):
    def get(self, request, user_id):
        ref = db.reference("personal_data").child(user_id)
        data = ref.get()
        if not data:
            return Response({'error': 'User not found'}, status=status.HTTP_404_NOT_FOUND)
        return Response(data, status=status.HTTP_200_OK)

    def put(self, request, user_id):
        ref = db.reference("personal_data").child(user_id)
        old_data = ref.get()
        if not old_data:
            return Response({'error': 'User not found'}, status=status.HTTP_404_NOT_FOUND)

        body = request.data
        updated_data = {
            'full_name': body.get('full_name', old_data.get('full_name', '')),
            'phone_number': body.get('phone_number', old_data.get('phone_number', '')),
            'birthdate': body.get('birthdate', old_data.get('birthdate', '2000-01-01')),
            'country': body.get('country', old_data.get('country', '')),
            'postal_code': body.get('postal_code', old_data.get('postal_code', '')),
            'address_1': body.get('address_1', old_data.get('address_1', '')),
            'address_2': body.get('address_2', old_data.get('address_2', '')),
        }

        ref.update(updated_data)
        return Response({'message': 'Record updated successfully'}, status=status.HTTP_200_OK)

    def delete(self, request, user_id):
        ref = db.reference("personal_data").child(user_id)
        ref.delete()
        return Response({'message': 'Record deleted successfully'}, status=status.HTTP_200_OK)

    
@api_view(['POST'])
def upload_national_card(request):
    try:
        front_national_card = request.FILES.get('id_front_card')
        back_national_card = request.FILES.get('id_back_card')
        user_id = request.data.get('user_id')  # or any unique user id you have

        if not front_national_card or not back_national_card or not user_id:
            return JsonResponse({'error': 'Front, back images and user_id are required.'}, status=400)

        main_folder_id = "1nIPlwpcUGkDK0hvCfU_TlrRJyt6EmSi5"

        # 1. Get or create user subfolder inside main folder
        user_folder_id = get_or_create_drive_folder(user_id, parent_folder_id=main_folder_id)

        # 2. Upload front image to user folder
        front_file_name = front_national_card.name
        front_image_url = upload_image_to_drive(front_national_card, front_file_name, user_folder_id)

        # 3. Upload back image to user folder
        back_file_name = back_national_card.name
        back_image_url = upload_image_to_drive(back_national_card, back_file_name, user_folder_id)

        # 4. Save URLs in Firebase with username key
        ref = db.reference("national_cards")
        ref.push().set({
            "user_id": user_id,
            "front_url": front_image_url,
            "back_url": back_image_url,
        })

        return JsonResponse({
            'message': 'National card uploaded successfully.',
            'front_url': front_image_url,
            'back_url': back_image_url
        })

    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


@api_view(['POST'])
def life_picture(request):
    try:
        uploaded_file = request.FILES.get('user_face_capture')
        user_id = request.POST.get('user_id')  # Get user_id from form data

        if not uploaded_file:
            return JsonResponse({'error': 'No image provided.'}, status=400)
        if not user_id:
            return JsonResponse({'error': 'No user ID provided.'}, status=400)

        import uuid
        file_name = f"{uuid.uuid4()}_{uploaded_file.name}"
        folder_id = "1fWzuK6MIqsKCVncaLYhV7wB6qfhDWBMd"

        image_url = upload_image_to_drive(uploaded_file, file_name, folder_id)

        # Store under a user-specific path
        ref = db.reference(f"users/{user_id}")
        ref.update({"profile_picture": image_url})

        return JsonResponse({'message': 'Life picture uploaded.', 'url': image_url})

    except Exception as e:
        print("Error uploading life picture:", str(e))
        return JsonResponse({'error': str(e)}, status=500)


@api_view(['POST'])
def send_reset_link(request):
    email = request.data.get('email')
    if not email:
        return Response({"error": "Email is required"}, status=400)

    try:
        send_password_reset_email_custom(email)
        return Response({"message": "Reset link sent successfully"})
    except Exception as e:
        return Response({"error": str(e)}, status=500)


@api_view(['GET'])
def reset_password_with_code(request):
    oob_code = request.data.get('oob_code')
    new_password = request.data.get('new_password')

    if not oob_code or not new_password:
        return Response({"error": "Missing oob_code or password"}, status=400)

    try:
        auth.confirm_password_reset(oob_code, new_password)
        return Response({"message": "Password has been reset successfully"})
    except Exception as e:
        return Response({"error": str(e)}, status=400)

@api_view(['POST'])
@parser_classes([MultiPartParser, FormParser])
def upload_video(request):
    national_id = request.data.get('national_id')
    video = request.FILES.get('video')

    if not national_id or not video:
        return Response({'error': 'national_id and video are required.'}, status=status.HTTP_400_BAD_REQUEST)

    filename = f"{uuid.uuid4()}.mp4"
    with open(filename, 'wb+') as f:
        for chunk in video.chunks():
            f.write(chunk)

    try:
        drive_filename = f"{national_id}_reel.mp4"
        video_url = upload_video_to_drive(filename, drive_filename)  # only 2 args now

        db.reference(f'reels/{national_id}').set({'video_url': video_url})

        return Response({'message': 'Video uploaded', 'video_url': video_url}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    finally:
        if os.path.exists(filename):
            os.remove(filename)


@api_view(['GET'])
def get_reels(request):
    """
    Get all reels stored in Firebase Realtime Database.
    """
    try:
        reels_ref = db.reference("reels")
        reels_data = reels_ref.get()

        if not reels_data:
            return Response({"reels": []}, status=200)

        # Convert reels to a list of dicts with reel_id included
        reels_list = [
            {"reel_id": reel_id, **reel_info}
            for reel_id, reel_info in reels_data.items()
        ]

        return Response({"reels": reels_list}, status=200)

    except Exception as e:
        return Response({"error": str(e)}, status=500) 




@api_view(['POST'])
def user_profile_details_update(request):
    try:
        data = json.loads(request.body.decode('utf-8'))
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON in request body'}, status=400)

    user_id = data.get('user_id')
    if not user_id:
        return JsonResponse({'error': 'User ID is required.'}, status=400)

    update_data = {
        "gender": data.get('gender'),
        "employmentStatus": data.get('employment_status'),
        "primarySourceOfFund": data.get('primary_source_of_fund'),
        "monthlyIncome": data.get('monthly_income'),
        "monthlySave": data.get('monthly_save'),
    }

    update_data = {k: v for k, v in update_data.items() if v is not None}

    try:
        user_ref = db.reference('users').child(str(user_id))
        user_ref.update(update_data)
        return JsonResponse({"message": "User profile details updated successfully."}, status=200)
    except Exception as e:
        print(f"Error updating user profile details: {e}")
        return JsonResponse({"error": "Failed to update profile details.", "details": str(e)}, status=500)
