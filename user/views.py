import json
from django.http import JsonResponse, HttpResponseBadRequest
from django.views.decorators.csrf import csrf_exempt
from Investa.utils import send_otp_email, upload_video_to_drive, send_password_reset_email_custom, upload_image_to_drive
from django.core.cache import cache
from firebase_admin import auth, db
from rest_framework.response import Response
from rest_framework.decorators import api_view, parser_classes
from rest_framework.parsers import MultiPartParser, FormParser
import os
import uuid
from rest_framework import status
from django.conf import settings
import requests


@api_view(['POST'])
def request_otp(request):
    """Send OTP and temporarily store user details using Firebase-generated ID."""
    try:
        data = json.loads(request.body)
        email = data.get("email")
        password = data.get("password")
        username = data.get("username")
        dob = data.get("date_of_birth")

        if not email or not password:
            return JsonResponse({"error": "Email and Password are required"}, status=400)

        # Check if email already exists
        users_ref = db.reference("users")
        existing_users = users_ref.order_by_child("email").equal_to(email).get()
        if existing_users:
            return JsonResponse({"error": "Email already exists"}, status=400)

        # Send OTP
        send_otp_email(email)

        # Generate a new Firebase user ID for temporary storage
        temp_user_ref = users_ref.push({})
        temp_user_id = temp_user_ref.key

        # Cache user details for OTP verification
        user_data = {
            "firebase_user_id": temp_user_id,
            "email": email,
            "password": password,
            "username": username,
            "date_of_birth": dob
        }
        cache.set(f"user_data_{email}", user_data, timeout=600)

        return JsonResponse({"message": "OTP sent to email"}, status=200)

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)
    
    
@api_view(['POST'])
def verify_otp(request):
    """Verify OTP and create user after successful verification (no profile picture)."""
    if request.method != "POST":
        return JsonResponse({"error": "Invalid request"}, status=405)

    try:
        if not request.content_type.startswith("multipart/form-data"):
            return JsonResponse({"error": "Request content-type must be multipart/form-data"}, status=400)

        email = request.POST.get("email")
        otp_entered = request.POST.get("otp")

        stored_otp = cache.get(email)
        if not stored_otp or stored_otp != otp_entered:
            return JsonResponse({"error": "Invalid or expired OTP"}, status=400)

        cache.delete(email)  # OTP is used, delete it

        # Retrieve stored user data
        user_data = cache.get(f"user_data_{email}")
        if not user_data:
            return JsonResponse({"error": "User data expired. Please sign up again."}, status=400)

        # Create user in Firebase Authentication
        user = auth.create_user(
            email=user_data["email"],
            password=user_data["password"],
            display_name=user_data["username"]
        )

        # Use the UID generated by Firebase Auth
        firebase_user_id = user.uid

        # Save user details in Firebase Realtime Database
        users_ref = db.reference("users")
        user_info = {
            "email": user_data["email"],
            "username": user_data["username"],
            "date_of_birth": user_data["date_of_birth"]
        }
        users_ref.child(firebase_user_id).set(user_info)

        # Clear cache
        cache.delete(f"user_data_{email}")

        return JsonResponse({
            "message": "Account created successfully",
            "user_id": firebase_user_id
        }, status=201)

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)


@csrf_exempt
def personal_data_list(request):
    """Handle fetching and storing personal data in Firebase using national ID."""
    ref = db.reference("personal_data")

    if request.method == 'GET':
        data = ref.get()
        return JsonResponse(data if data else {}, status=200, safe=False)

    elif request.method == 'POST':
        try:
            body = json.loads(request.body.decode('utf-8'))
            national_id = body.get('national_id')

            if not national_id:
                return JsonResponse({'error': 'National ID is required'}, status=400)

            # Check if national ID already exists
            existing_data = ref.child(national_id).get()
            if existing_data:
                return JsonResponse({'error': 'National ID already exists'}, status=400)

            ref.child(national_id).set({
                'full_name': body.get('full_name', ''),
                'national_id': national_id,
                'phone_number': body.get('phone_number', ''),
                'birthdate': body.get('birthdate', '2000-01-01'),
                'governor': body.get('governor', ''),
                'postal_code': body.get('postal_code', ''),
                'address': body.get('address', ''),
                'email': body.get('email', ''),
            })

            return JsonResponse({'message': 'Record created successfully', 'national_id': national_id}, status=201)
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=400)

    return JsonResponse({'error': 'Method not allowed'}, status=405)

@csrf_exempt
def personal_data_detail(request, national_id):
    """Fetch, update, or delete personal data by national ID."""
    ref = db.reference("personal_data").child(national_id)

    if request.method == 'GET':
        data = ref.get()
        if not data:
            return JsonResponse({'error': 'User not found'}, status=404)
        return JsonResponse(data, status=200)

    elif request.method == 'PUT':
        try:
            body = json.loads(request.body.decode('utf-8'))
            old_data = ref.get()
            if not old_data:
                return JsonResponse({'error': 'User not found'}, status=404)

            updated_data = {
                'full_name': body.get('full_name') or old_data.get('full_name', ''),
                'phone_number': body.get('phone_number') or old_data.get('phone_number', ''),
                'birthdate': body.get('birthdate') or old_data.get('birthdate', '2000-01-01'),
                'governor': body.get('governor') or old_data.get('governor', ''),
                'postal_code': body.get('postal_code') or old_data.get('postal_code', ''),
                'address': body.get('address') or  old_data.get('address', ''),
            }

            ref.update(updated_data)

            return JsonResponse({'message': 'Record updated successfully'}, status=200)
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=400)

    elif request.method == 'DELETE':
        ref.delete()
        return JsonResponse({'message': 'Record deleted successfully'}, status=200)

    return JsonResponse({'error': 'Method not allowed'}, status=405)


@api_view(['POST'])
def sign_in(request):
    try:
        data = json.loads(request.body)
        email = data.get("email")
        password = data.get("password")

        if not email or not password:
            return JsonResponse({"message": "Missing email or password"}, status=400)

        # Firebase REST API endpoint for sign in
        url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={settings.FIREBASE_WEB_API_KEY}"

        payload = {
            "email": email,
            "password": password,
            "returnSecureToken": True
        }

        response = requests.post(url, json=payload)
        result = response.json()

        if "error" in result:
            return JsonResponse({"message": result["error"]["message"]}, status=401)

        return JsonResponse({
            "message": "Sign-in successful",
            "idToken": result["idToken"],
            "refreshToken": result["refreshToken"],
            "user_id": result["localId"],
            "email": result["email"]
        })

    except Exception as e:
        return JsonResponse({"message": f"Error: {str(e)}"}, status=500)


'''@api_view(['POST'])
def submit_review(request):
    data = request.data

    project_id = data.get('project_id')
    name = data.get('name')
    rating = data.get('rating')
    comment = data.get('comment')

    # Validate required fields
    if not all([project_id, name, rating]):
        return Response({"error": "project_id, name, and rating are required."}, status=400)

    # Construct review object
    review = {
        "name": name,
        "rating": rating,  # Integer from 1 to 5 (your frontend should convert stars to numbers)
        "comment": comment or ""  # Optional comment
    }

    # Save to Firebase Realtime DB
    try:
        db.reference(f"projects/{project_id}/reviews").push(review)
        return Response({"message": "Review submitted successfully."}, status=201)
    except Exception as e:
        return Response({"error": str(e)}, status=500)'''


@api_view(['POST'])
def send_reset_link(request):
    email = request.data.get('email')
    if not email:
        return Response({"error": "Email is required"}, status=400)

    try:
        send_password_reset_email_custom(email)
        return Response({"message": "Reset link sent successfully"})
    except Exception as e:
        return Response({"error": str(e)}, status=500)


@api_view(['GET'])
def reset_password_with_code(request):
    oob_code = request.data.get('oob_code')
    new_password = request.data.get('new_password')

    if not oob_code or not new_password:
        return Response({"error": "Missing oob_code or password"}, status=400)

    try:
        auth.confirm_password_reset(oob_code, new_password)
        return Response({"message": "Password has been reset successfully"})
    except Exception as e:
        return Response({"error": str(e)}, status=400)

@api_view(['POST'])
@parser_classes([MultiPartParser, FormParser])
def upload_video(request):
    national_id = request.data.get('national_id')
    video = request.FILES.get('video')

    if not national_id or not video:
        return Response({'error': 'national_id and video are required.'}, status=status.HTTP_400_BAD_REQUEST)

    filename = f"{uuid.uuid4()}.mp4"
    with open(filename, 'wb+') as f:
        for chunk in video.chunks():
            f.write(chunk)

    try:
        drive_filename = f"{national_id}_reel.mp4"
        video_url = upload_video_to_drive(filename, drive_filename)  # only 2 args now

        db.reference(f'reels/{national_id}').set({'video_url': video_url})

        return Response({'message': 'Video uploaded', 'video_url': video_url}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    finally:
        if os.path.exists(filename):
            os.remove(filename)



@api_view(['GET'])
def get_reels(request):
    """
    Get all reels stored in Firebase Realtime Database.
    """
    try:
        reels_ref = db.reference("reels")
        reels_data = reels_ref.get()

        if not reels_data:
            return Response({"reels": []}, status=200)

        # Convert reels to a list of dicts with reel_id included
        reels_list = [
            {"reel_id": reel_id, **reel_info}
            for reel_id, reel_info in reels_data.items()
        ]

        return Response({"reels": reels_list}, status=200)

    except Exception as e:
        return Response({"error": str(e)}, status=500) 
    

@csrf_exempt
def upload_national_card(request):
    if request.method == 'POST':
        try:
            uploaded_file = request.FILES.get('image')
            if not uploaded_file:
                return JsonResponse({'error': 'No image provided.'}, status=400)

            file_name = uploaded_file.name
            folder_id = "1nIPlwpcUGkDK0hvCfU_TlrRJyt6EmSi5"  # مجلد البطاقات القومية

            image_url = upload_image_to_drive(uploaded_file, file_name, folder_id)

            ref = db.reference("national_cards")
            ref.push().set({"url": image_url})

            return JsonResponse({'message': 'National card uploaded.', 'url': image_url})

        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)

    return JsonResponse({'error': 'Invalid request method.'}, status=405)
