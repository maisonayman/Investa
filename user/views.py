import json
from django.http import JsonResponse, HttpResponseBadRequest
from Investa.utils import send_otp_email, upload_video_to_drive, send_password_reset_email_custom, upload_image_to_drive, get_or_create_drive_folder
from django.core.cache import cache
from firebase_admin import auth, db
from rest_framework.response import Response
from rest_framework.decorators import api_view, parser_classes, permission_classes
from rest_framework.parsers import MultiPartParser, FormParser
import os
import uuid
from rest_framework import status
from django.conf import settings
import requests
from rest_framework.views import APIView
from datetime import datetime
import re
import cv2
import tempfile
import easyocr
from ultralytics import YOLO

@api_view(['POST'])
def request_otp(request):
    """Send OTP and temporarily store user details using Firebase-generated ID."""
    try:
        data = json.loads(request.body)
        email = data.get("email")
        password = data.get("password")
        username = data.get("username")
        dob = data.get("date_of_birth")

        if not email or not password:
            return JsonResponse({"error": "Email and Password are required"}, status=400)

        # Check if email already exists
        users_ref = db.reference("users")
        existing_users = users_ref.order_by_child("email").equal_to(email).get()
        if existing_users:
            return JsonResponse({"error": "Email already exists"}, status=400)

        # Send OTP
        send_otp_email(email)

        # Generate a new Firebase user ID for temporary storage
        temp_user_ref = users_ref.push({})
        temp_user_id = temp_user_ref.key

        # Cache user details for OTP verification
        user_data = {
            "firebase_user_id": temp_user_id,
            "email": email,
            "password": password,
            "username": username,
            "date_of_birth": dob
        }
        cache.set(f"user_data_{email}", user_data, timeout=600)

        return JsonResponse({"message": "OTP sent to email"}, status=200)

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)
    
    
@api_view(['POST'])
def verify_otp(request):
    """Verify OTP and create user after successful verification (no profile picture)."""
    if request.method != "POST":
        return JsonResponse({"error": "Invalid request"}, status=405)

    try:
        if not request.content_type.startswith("multipart/form-data"):
            return JsonResponse({"error": "Request content-type must be multipart/form-data"}, status=402)

        email = request.POST.get("email")
        otp_entered = request.POST.get("otp")

        stored_otp = cache.get(email)
        if not stored_otp or stored_otp != otp_entered:
            return JsonResponse({"error": "Invalid or expired OTP"}, status=403)

        cache.delete(email)  # OTP is used, delete it

        # Retrieve stored user data
        user_data = cache.get(f"user_data_{email}")
        if not user_data:
            return JsonResponse({"error": "User data expired. Please sign up again."}, status=404)

        # Create user in Firebase Authentication
        user = auth.create_user(
            email=user_data["email"],
            password=user_data["password"],
            display_name=user_data["username"]
        )

        # Use the UID generated by Firebase Auth
        firebase_user_id = user.uid

        # Save user details in Firebase Realtime Database
        users_ref = db.reference("users")
        user_info = {
            "email": user_data["email"],
            "username": user_data["username"],
            "date_of_birth": user_data["date_of_birth"]
        }
        users_ref.child(firebase_user_id).set(user_info)

        # Clear cache
        cache.delete(f"user_data_{email}")

        return JsonResponse({
            "message": "Account created successfully",
            "user_id": firebase_user_id
        }, status=201)

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)


@api_view(['POST'])
def sign_in(request):
    try:
        data = json.loads(request.body)
        email = data.get("email")
        password = data.get("password")

        if not email or not password:
            return JsonResponse({"message": "Email and password are required."}, status=400)

        url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={settings.FIREBASE_WEB_API_KEY}"
        payload = {
            "email": email,
            "password": password,
            "returnSecureToken": True
        }

        response = requests.post(url, json=payload)
        result = response.json()

        if "error" in result:
            error_message = result["error"]["message"]
            if error_message in ["EMAIL_NOT_FOUND", "INVALID_PASSWORD"]:
                return JsonResponse({"message": "Invalid email or password."}, status=401)
            elif error_message == "USER_DISABLED":
                return JsonResponse({"message": "Your account has been disabled."}, status=403)
            else:
                return JsonResponse({"message": "Login failed. Please try again."}, status=400)

        user_id = result["localId"]
        id_token = result["idToken"]
        refresh_token = result["refreshToken"]
        email = result["email"]

        db_url = f"{settings.FIREBASE_DB_URL}/users/{user_id}.json?auth={id_token}"
        user_response = requests.get(db_url)
        user_data = user_response.json()

        if user_data is None:
            return JsonResponse({
                "message": "Sign-in successful, but user details not found.",
                "idToken": id_token,
                "refreshToken": refresh_token,
                "user_id": user_id,
                "email": email
            })

        role = user_data.get("role")

        if not role:
            return JsonResponse({
                "message": "Sign-in successful, but user has no role assigned.",
                "user_id": user_id,
                "email": email,
                "idToken": id_token,
                "refreshToken": refresh_token
            })

        if role == "investor":
            interests = user_data.get("interests")
            if interests:
                return JsonResponse({
                    "message": "Investor has interests.",
                    "role": role,
                    "user_id": user_id,
                    "email": email,
                    "interests": interests,
                    "idToken": id_token,
                    "refreshToken": refresh_token
                })
            else:
                return JsonResponse({
                    "message": "Investor has no interests yet.",
                    "role": role,
                    "user_id": user_id,
                    "email": email,
                    "idToken": id_token,
                    "refreshToken": refresh_token
                })

        elif role == "founder":
            projects_ref = db.reference('projects')
            all_projects = projects_ref.get() or {}

            has_project = any(
                proj.get("user_id") == user_id for proj in all_projects.values()
            )

            if has_project:
                return JsonResponse({
                    "message": "Founder has project(s).",
                    "role": role,
                    "user_id": user_id,
                    "email": email,
                    "idToken": id_token,
                    "refreshToken": refresh_token
                })
            else:
                return JsonResponse({
                    "message": "Founder has no projects yet.",
                    "role": role,
                    "user_id": user_id,
                    "email": email,
                    "idToken": id_token,
                    "refreshToken": refresh_token
                })

        else:
            return JsonResponse({
                "message": f"User has unknown role: {role}",
                "role": role,
                "user_id": user_id,
                "email": email,
                "idToken": id_token,
                "refreshToken": refresh_token
            })

    except Exception as e:
        return JsonResponse({
            "message": f"An unexpected error occurred: {str(e)}"
        }, status=500)



class PersonalDataList(APIView):
    def get(self, request):
        ref = db.reference("users")
        data = ref.get()
        return Response(data if data else {}, status=status.HTTP_200_OK)

    def post(self, request):
        try:
            body = request.data
            user_id = body.get('user_id')

            if not user_id:
                return Response({'error': 'user_id is required.'}, status=status.HTTP_400_BAD_REQUEST)

            ref = db.reference("users").child(user_id)

            ref.set({
                'full_name': body.get('full_name', '').strip(),
                'national_id': body.get('national_number', '').strip(),
                'phone_number': body.get('phone_number', '').strip(),
                'birthdate': body.get('birthdate', '2000-01-01').strip(),
                'country': body.get('country', '').strip(),
                'postal_code': body.get('postal_code', '').strip(),
                'address_1': body.get('address_1', '').strip(),
                'address_2': body.get('address_2', '').strip(),
            })

            return Response({'message': 'Personal data saved.'}, status=status.HTTP_201_CREATED)

        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


class PersonalDataDetail(APIView):
    def get(self, request, user_id):
        try:
            ref = db.reference(f"users/{user_id}")
            data = ref.get()

            if not data:
                return Response({'error': 'User not found.'}, status=status.HTTP_404_NOT_FOUND)

            return Response(data, status=status.HTTP_200_OK)

        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def put(self, request, user_id):
        try:
            ref = db.reference(f"users/{user_id}")
            existing_data = ref.get()

            if not existing_data:
                return Response({'error': 'User not found.'}, status=status.HTTP_404_NOT_FOUND)

            body = request.data

            ref.update({
                'full_name': body.get('full_name', existing_data.get('full_name', '')).strip(),
                'national_id': body.get('national_number', existing_data.get('national_id', '')).strip(),
                'phone_number': body.get('phone_number', existing_data.get('phone_number', '')).strip(),
                'birthdate': body.get('birthdate', existing_data.get('birthdate', '2000-01-01')).strip(),
                'country': body.get('country', existing_data.get('country', '')).strip(),
                'postal_code': body.get('postal_code', existing_data.get('postal_code', '')).strip(),
                'address_1': body.get('address_1', existing_data.get('address_1', '')).strip(),
                'address_2': body.get('address_2', existing_data.get('address_2', '')).strip(),
            })

            return Response({'message': 'Personal data updated.'}, status=status.HTTP_200_OK)

        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def delete(self, request, user_id):
        try:
            ref = db.reference(f"users/{user_id}")
            if ref.get():
                ref.delete()
                return Response({'message': 'User data deleted.'}, status=status.HTTP_200_OK)
            else:
                return Response({'error': 'User not found.'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
def profile_details(request):
    try:
        data = json.loads(request.body.decode('utf-8'))
        user_id = data.get('user_id')

        if not user_id:
            return JsonResponse({'error': 'user_id is required.'}, status=400)

        update_data = {
            "gender": data.get('gender'),
            "employmentStatus": data.get('employment_status'),
            "primarySourceOfFund": data.get('primary_source_of_fund'),
            "monthlyIncome": data.get('monthly_income'),
            "monthlySave": data.get('monthly_save'),
            "submitted_at": datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
        update_data = {k: v for k, v in update_data.items() if v is not None}

        db.reference('users').child(user_id).child('profile_details').set(update_data)
        return JsonResponse({"message": "Profile details saved successfully."}, status=200)

    except Exception as e:
        return JsonResponse({"error": "Failed to save profile details.", "details": str(e)}, status=500)


@api_view(['POST'])
def investment_details(request):
    try:
        data = json.loads(request.body.decode('utf-8'))
        user_id = data.get('user_id')

        if not user_id:
            return Response({'error': 'user_id is required.'}, status=400)

        investment_data = {
            "investment_type": data.get('investment_term'),
            "purpose_investment": data.get('description'),
            "submitted_at": datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
        investment_data = {k: v for k, v in investment_data.items() if v is not None}

        db.reference('users').child(user_id).child('investment_details').set(investment_data)
        return Response({"message": "Investment details saved."}, status=200)

    except Exception as e:
        return Response({"error": "Failed to submit investment data.", "details": str(e)}, status=500)


"""
National ID Card Processing Module

This module handles the processing, validation, and storage of Egyptian national ID cards.
It uses computer vision and OCR to extract data from ID card images.
"""

import os
import re
import cv2
import tempfile
from rest_framework.decorators import api_view
from django.http import JsonResponse
from ultralytics import YOLO

# ====================================================
# CONFIGURATION AND INITIALIZATION
# ====================================================


# Enhanced helper function to find model files with fallback paths
def get_model_path(model_name):
    """
    Get the path to a model file with fallback options.
    
    Args:
        model_name: Name of the model file
        
    Returns:
        str: Path to the model file if found, otherwise raises FileNotFoundError
    """
    # List of possible locations to check
    possible_paths = [
        # Relative to the current file
        os.path.join(os.path.dirname(__file__), 'saved_models', model_name),
        
        # Relative to the project root
        os.path.join(os.path.dirname(os.path.dirname(__file__)), 'saved_models', model_name),
        
        # Absolute path options
        os.path.abspath(os.path.join('saved_models', model_name)),
        
        # Just the model name (if it's in the Python path)
        model_name,
    ]
    
    # Check if any of the paths exist
    for path in possible_paths:
        if os.path.exists(path):
            print(f"Found model at: {path}")
            return path
    
    # If we got here, none of the paths worked
    raise FileNotFoundError(f"Could not find model file: {model_name}. Searched in: {possible_paths}")

# Function to safely load YOLO model with error handling
def load_yolo_model(model_name):
    """
    Safely load a YOLO model with error handling.
    
    Args:
        model_name: Name of the model file
    
    Returns:
        YOLO model if successful, None if failed
    """
    try:
        model_path = get_model_path(model_name)
        print(f"Loading model from: {model_path}")
        return YOLO(model_path)
    except Exception as e:
        print(f"Error loading model {model_name}: {str(e)}")
        return None

# ====================================================
# UTILITY FUNCTIONS
# ====================================================

def expand_bbox_height(bbox, scale=1.2, image_shape=None):
    """
    Expand the height of a bounding box while keeping the width constant.
    
    Args:
        bbox: List containing [x1, y1, x2, y2] coordinates
        scale: Factor by which to scale the height
        image_shape: Original image dimensions to prevent out-of-bounds coordinates
        
    Returns:
        List with the new bbox coordinates [x1, new_y1, x2, new_y2]
    """
    x1, y1, x2, y2 = bbox
    width = x2 - x1
    height = y2 - y1
    center_x = x1 + width // 2
    center_y = y1 + height // 2
    new_height = int(height * scale)
    new_y1 = max(center_y - new_height // 2, 0)
    new_y2 = min(center_y + new_height // 2, image_shape[0]) if image_shape else center_y + new_height // 2
    return [x1, new_y1, x2, new_y2]

def preprocess_image(cropped_image):
    """Convert image to grayscale for better OCR results."""
    gray_image = cv2.cvtColor(cropped_image, cv2.COLOR_BGR2GRAY)   
    return gray_image

# ====================================================
# ID CARD PROCESSING
# ====================================================

def process_image(cropped_image):
    """
    Extract all relevant information from a cropped ID card image.
    
    Args:
        cropped_image: The cropped image containing just the ID card
        
    Returns:
        Tuple containing extracted information:
        (first_name, second_name, merged_name, nid, address, birth_date, governorate, gender)
    """
    # Load the trained YOLO model for objects (fields) detection
    model = YOLO(get_model_path('detect_odjects.pt'))
    results = model(cropped_image)

    # Variables to store extracted values
    first_name = ''
    second_name = ''
    merged_name = ''
    nid = ''
    address = ''
    serial = ''

    # Decode additional information from the ID number
    decoded_info = decode_egyptian_id(nid)
    return (first_name, second_name, nid, address, decoded_info["Birth Date"], 
            decoded_info["Governorate"], decoded_info["Gender"])

def detect_and_process_id_card(image_path):
    """
    Detect an ID card in an image and extract information from it.
    
    Args:
        image_path: Path to the image file
        
    Returns:
        Tuple containing extracted ID information
    """
    # Load the ID card detection model
    id_card_model = YOLO(get_model_path('detect_id_card.pt'))
    
    # Perform inference to detect the ID card
    id_card_results = id_card_model(image_path)
    # Load the original image using OpenCV
    image = cv2.imread(image_path)

    # Crop the ID card from the image
    cropped_image = None
    for result in id_card_results:
        for box in result.boxes:
            x1, y1, x2, y2 = map(int, box.xyxy[0])  # Get bounding box coordinates
            cropped_image = image[y1:y2, x1:x2]
            break  # Take the first detected ID card
        if cropped_image is not None:
            break
    
    if cropped_image is None:
        raise ValueError("No ID card detected in the image")

    # Pass the cropped image to the processing function
    return process_image(cropped_image)

def decode_egyptian_id(id_number):
    """
    Decode Egyptian national ID number to extract demographic information.
    
    Args:
        id_number: 14-digit Egyptian national ID number
        
    Returns:
        Dictionary with decoded information (birth date, governorate, gender)
    """
    if not id_number or len(id_number) != 14 or not id_number.isdigit():
        return {
            'Birth Date': 'Unknown',
            'Governorate': 'Unknown',
            'Gender': 'Unknown'
        }
        
    governorates = {
        '01': 'Cairo',
        '02': 'Alexandria',
        '03': 'Port Said',
        '04': 'Suez',
        '11': 'Damietta',
        '12': 'Dakahlia',
        '13': 'Ash Sharqia',
        '14': 'Kaliobeya',
        '15': 'Kafr El - Sheikh',
        '16': 'Gharbia',
        '17': 'Monoufia',
        '18': 'El Beheira',
        '19': 'Ismailia',
        '21': 'Giza',
        '22': 'Beni Suef',
        '23': 'Fayoum',
        '24': 'El Menia',
        '25': 'Assiut',
        '26': 'Sohag',
        '27': 'Qena',
        '28': 'Aswan',
        '29': 'Luxor',
        '31': 'Red Sea',
        '32': 'New Valley',
        '33': 'Matrouh',
        '34': 'North Sinai',
        '35': 'South Sinai',
        '88': 'Foreign'
    }

    try:
        century_digit = int(id_number[0])
        year = int(id_number[1:3])
        month = int(id_number[3:5])
        day = int(id_number[5:7])
        governorate_code = id_number[7:9]
        gender_code = int(id_number[12:13])

        if century_digit == 2:
            full_year = 1900 + year
        elif century_digit == 3:
            full_year = 2000 + year
        else:
            raise ValueError("Invalid century digit")
            
        # Validate date
        if month < 1 or month > 12 or day < 1 or day > 31:
            raise ValueError("Invalid date in ID")

        gender = "Male" if gender_code % 2 != 0 else "Female"
        governorate = governorates.get(governorate_code, "Unknown")
        birth_date = f"{full_year:04d}-{month:02d}-{day:02d}"

        return {
            'Birth Date': birth_date,
            'Governorate': governorate,
            'Gender': gender
        }
    except (ValueError, IndexError) as e:
        print(f"Error decoding ID number: {str(e)}")
        return {
            'Birth Date': 'Unknown',
            'Governorate': 'Unknown',
            'Gender': 'Unknown'
        }

# ====================================================
# API ENDPOINTS
# ====================================================

@api_view(['POST'])
def upload_national_card(request):
    """
    Upload and validate national ID card front and back images.
    
    Performs validation on:
    - Required fields
    - Image format and size
    - ID card detection
    - ID information extraction
    
    Args:
        request: HTTP request with form data containing:
            - id_front_image: Front image of the national ID card
            - id_back_image: Back image of the national ID card
            - user_id: User identifier
            
    Returns:
        JsonResponse with upload result or error details
    """
    errors = {}
    temp_files = []
    id_card_model = None
    
    try:
        # Required field validation
        front_national_card = request.FILES.get('id_front_image')
        back_national_card = request.FILES.get('id_back_image')
        user_id = request.data.get('user_id')
        
        if not user_id:
            errors['user_id'] = 'User ID is required'
        if not front_national_card:
            errors['front_image'] = 'Front image is required'
        if not back_national_card:
            errors['back_image'] = 'Back image is required'
            
        if errors:
            return JsonResponse({'error': 'Missing required fields', 'details': errors}, status=400)
            
        # File type validation
        allowed_types = ['image/jpeg', 'image/png', 'image/jpg']
        max_size = 5 * 1024 * 1024  # 5MB limit
        
        if front_national_card.content_type not in allowed_types:
            errors['front_image'] = f'Invalid format: {front_national_card.content_type}. Use JPEG/PNG only'
        elif front_national_card.size > max_size:
            errors['front_image'] = 'Image exceeds 5MB size limit'
            
        if back_national_card.content_type not in allowed_types:
            errors['back_image'] = f'Invalid format: {back_national_card.content_type}. Use JPEG/PNG only'
        elif back_national_card.size > max_size:
            errors['back_image'] = 'Image exceeds 5MB size limit'
            
        if errors:
            return JsonResponse({'error': 'Invalid files', 'details': errors}, status=400)
        
        # Save images to temporary files for processing
        front_temp = tempfile.NamedTemporaryFile(suffix='.jpg', delete=False)
        for chunk in front_national_card.chunks():
            front_temp.write(chunk)
        front_temp.close()
        temp_files.append(front_temp.name)
        
        back_temp = tempfile.NamedTemporaryFile(suffix='.jpg', delete=False)
        for chunk in back_national_card.chunks():
            back_temp.write(chunk)
        back_temp.close()
        temp_files.append(back_temp.name)
        
        # Try to load the ID card model
        id_card_model = load_yolo_model('detect_id_card.pt')
        
        if id_card_model is None:
            return JsonResponse({
                'error': 'Configuration error',
                'details': {'system': 'Failed to load ID card detection model. Please contact support.'}
            }, status=500)
        
        # ID card validation for front image
        try:
            front_results = id_card_model(front_temp.name)
            
            if len(front_results[0].boxes) == 0:
                errors['front_image'] = 'No national ID card detected in the image'
            else:
                # Try to extract information from the ID card
                try:
                    digit_model = load_yolo_model('detect_id.pt')
                    object_model = load_yolo_model('detect_odjects.pt')
                    
                    if digit_model is None or object_model is None:
                        errors['front_image'] = 'System could not load required models for ID processing'
                    else:
                        # Updated to use your existing detection function
                        id_info = detect_and_process_id_card(front_temp.name)
                        id_number = id_info[3]  # National ID number
                        
                        # Validate ID number (14 digits for Egyptian IDs)
                        #if not id_number or not re.match(r'^\d{14}$', id_number):
                         #   errors['front_image'] = 'Invalid or unreadable ID number'
                except Exception as e:
                    errors['front_image'] = f'Cannot extract information from ID card: {str(e)[:100]}. Please provide a clearer image'
        except Exception as e:
            errors['front_image'] = f'Failed to validate ID card: {str(e)[:100]}'
            
        # Basic validation for back image
        try:
            back_results = id_card_model(back_temp.name)
            if len(back_results[0].boxes) == 0:
                errors['back_image'] = 'No national ID card detected in the back image'
        except Exception as e:
            errors['back_image'] = f'Failed to validate back of ID card: {str(e)[:100]}'
            
        if errors:
            return JsonResponse({'error': 'ID validation failed', 'details': errors}, status=400)
        
        # If all validation passes, proceed with upload to Google Drive
        main_folder_id = "1nIPlwpcUGkDK0hvCfU_TlrRJyt6EmSi5"
        user_folder_id = get_or_create_drive_folder(user_id, parent_folder_id=main_folder_id)

        front_file_name = front_national_card.name
        front_image_url = upload_image_to_drive(front_national_card, front_file_name, user_folder_id)

        back_file_name = back_national_card.name
        back_image_url = upload_image_to_drive(back_national_card, back_file_name, user_folder_id)

        # Store the data in Firebase with extracted information
        ref = db.reference("users").child(user_id).child("national_card")
        data = {
            "front_url": front_image_url,
            "back_url": back_image_url,
            "verified": True
        }
        
            
        ref.set(data)

        # Return the original response structure to maintain frontend contract
        return JsonResponse({
            'message': 'National card uploaded.',
            'front_url': front_image_url,
            'back_url': back_image_url
        })

    except Exception as e:
        return JsonResponse({'error': f'Server error: {str(e)[:200]}'}, status=500)
    finally:
        # Clean up temporary files
        for temp_file in temp_files:
            try:
                os.unlink(temp_file)
            except Exception:
                pass  # Suppress cleanup errors


@api_view(['POST'])
def life_picture(request):
    try:
        uploaded_file = request.FILES.get('image')
        user_id = request.data.get('user_id')

        if not uploaded_file or not user_id:
            return JsonResponse({'error': 'user_id and image are required.'}, status=400)

        file_name = f"{uuid.uuid4()}_{uploaded_file.name}"
        folder_id = "1fWzuK6MIqsKCVncaLYhV7wB6qfhDWBMd"
        image_url = upload_image_to_drive(uploaded_file, file_name, folder_id)

        ref = db.reference("users").child(user_id)
        ref.update({"profile_picture": image_url})

        return JsonResponse({'message': 'Life picture uploaded.', 'url': image_url})

    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


@api_view(['POST'])
def set_user_role(request):
    user_id = request.data.get('user_id')
    role = request.data.get('role')  # 'investor' or 'founder'

    if not user_id or not role:
        return Response({'error': 'user_id and role are required.'}, status=status.HTTP_400_BAD_REQUEST)

    if role not in ['investor', 'founder']:
        return Response({'error': 'Invalid role. Must be investor or founder.'}, status=status.HTTP_400_BAD_REQUEST)

    try:
        user_ref = db.reference(f'users/{user_id}')
        user_ref.update({'role': role})

        return Response({'message': f'Role "{role}" set for user {user_id}.'}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
def send_reset_link(request):
    email = request.data.get('email')
    if not email:
        return Response({"error": "Email is required"}, status=400)

    try:
        send_password_reset_email_custom(email)
        return Response({"message": "Reset link sent successfully"})
    except Exception as e:
        return Response({"error": str(e)}, status=500)


@api_view(['GET'])
def reset_password_with_code(request):
    oob_code = request.data.get('oob_code')
    new_password = request.data.get('new_password')

    if not oob_code or not new_password:
        return Response({"error": "Missing oob_code or password"}, status=400)

    try:
        auth.confirm_password_reset(oob_code, new_password)
        return Response({"message": "Password has been reset successfully"})
    except Exception as e:
        return Response({"error": str(e)}, status=400)


@api_view(['POST'])
@parser_classes([MultiPartParser, FormParser])
def upload_video(request):
    user_id = request.data.get('user_id')
    video = request.FILES.get('video')

    if not user_id or not video:
        return Response({'error': 'user_id and video are required.'}, status=status.HTTP_400_BAD_REQUEST)

    filename = f"{uuid.uuid4()}.mp4"
    with open(filename, 'wb+') as f:
        for chunk in video.chunks():
            f.write(chunk)

    try:
        drive_filename = f"{uuid.uuid4()}_{user_id}_reel.mp4"  # Unique filename per upload
        folder_id = settings.FOLDER_ID_FOR_REELS
        video_url = upload_video_to_drive(filename, drive_filename, folder_id)

        # Use push to add a new reel entry instead of replacing existing
        db.reference(f'reels/{user_id}').push({
            'video_url': video_url,
            'timestamp': datetime.now().isoformat()
        })

        return Response({'message': 'Video uploaded', 'video_url': video_url}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    finally:
        if os.path.exists(filename):
            os.remove(filename)


@api_view(['GET'])
def get_reels(request):
    """
    Get all reels stored in Firebase Realtime Database.
    """
    try:
        reels_ref = db.reference("reels")
        reels_data = reels_ref.get()

        if not reels_data:
            return Response({"reels": []}, status=200)

        # Convert reels to a list of dicts with reel_id included
        reels_list = [
            {"reel_id": reel_id, **reel_info}
            for reel_id, reel_info in reels_data.items()
        ]

        return Response({"reels": reels_list}, status=200)

    except Exception as e:
        return Response({"error": str(e)}, status=500) 


@api_view(['POST'])
def change_password(request):
    try:
        data = request.data
        email = data.get('email')
        old_password = data.get('old_password')
        new_password = data.get('new_password')
        confirm_password = data.get('confirm_new_password')

        if not all([email, old_password, new_password, confirm_password]):
            return Response({'error': 'All fields are required.'}, status=400)

        if new_password != confirm_password:
            return Response({'error': 'New passwords do not match.'}, status=400)

        # Step 1: Sign in with email and old password
        sign_in_url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={settings.FIREBASE_API_KEY}"
        sign_in_payload = {
            "email": email,
            "password": old_password,
            "returnSecureToken": True
        }
        sign_in_response = requests.post(sign_in_url, json=sign_in_payload)

        if sign_in_response.status_code != 200:
            return Response({'error': 'Old password is incorrect.'}, status=400)

        id_token = sign_in_response.json().get('idToken')

        # Step 2: Update password
        update_url = f"https://identitytoolkit.googleapis.com/v1/accounts:update?key={settings.FIREBASE_API_KEY}"
        update_payload = {
            "idToken": id_token,
            "password": new_password,
            "returnSecureToken": True
        }
        update_response = requests.post(update_url, json=update_payload)

        if update_response.status_code == 200:
            return Response({'message': 'Password changed successfully.'}, status=200)
        else:
            return Response({'error': 'Failed to change password.'}, status=400)

    except Exception as e:
        return Response({'error': str(e)}, status=500)


@api_view(['POST'])
def change_email(request):
    try:
        data = request.data
        old_email = data.get('old_email')
        new_email = data.get('new_email')
        password = data.get('password')

        if not all([old_email, new_email, password]):
            return Response({'error': 'All fields are required.'}, status=400)

        # Step 1: Sign in with old email and password
        sign_in_url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={settings.FIREBASE_API_KEY}"
        sign_in_payload = {
            "email": old_email,
            "password": password,
            "returnSecureToken": True
        }
        sign_in_response = requests.post(sign_in_url, json=sign_in_payload)

        if sign_in_response.status_code != 200:
            return Response({'error': 'Incorrect old email or password.'}, status=400)

        id_token = sign_in_response.json().get('idToken')

        # Step 2: Change email
        update_url = f"https://identitytoolkit.googleapis.com/v1/accounts:update?key={settings.FIREBASE_API_KEY}"
        update_payload = {
            "idToken": id_token,
            "email": new_email,
            "returnSecureToken": True
        }
        update_response = requests.post(update_url, json=update_payload)

        if update_response.status_code == 200:
            return Response({'message': 'Email changed successfully.'}, status=200)
        else:
            return Response({'error': 'Failed to change email.'}, status=400)

    except Exception as e:
        return Response({'error': str(e)}, status=500)


@api_view(['POST'])
def delete_account(request):
    try:
        data = request.data
        email = data.get("email")
        password = data.get("password")
        user_id = data.get("user_id")

        if not all([email, password, user_id]):
            return Response({"error": "email, password, and user_id are required."}, status=400)

        # Step 1: Sign in to get idToken
        sign_in_url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={settings.FIREBASE_API_KEY}"
        sign_in_payload = {
            "email": email,
            "password": password,
            "returnSecureToken": True
        }
        sign_in_response = requests.post(sign_in_url, json=sign_in_payload)

        if sign_in_response.status_code != 200:
            return Response({"error": "Authentication failed. Check email or password."}, status=401)

        id_token = sign_in_response.json().get("idToken")

        # Step 2: Delete from Firebase Authentication
        delete_auth_url = f"https://identitytoolkit.googleapis.com/v1/accounts:delete?key={settings.FIREBASE_API_KEY}"
        delete_auth_response = requests.post(delete_auth_url, json={"idToken": id_token})

        if delete_auth_response.status_code != 200:
            return Response({"error": "Failed to delete from Firebase Auth."}, status=400)

        # Step 3: Delete all associated nodes in Realtime Database
        paths_to_delete = [
            f"users/{user_id}",
            f"saved_projects/{user_id}",
            f"invested_projects/{user_id}", 
            f"projects/{user_id}", 
            f"reels/{user_id}"  
        ]

        for path in paths_to_delete:
            db.reference(path).delete()

        return Response({"message": "User account and all related data deleted successfully."}, status=200)

    except Exception as e:
        return Response({"error": str(e)}, status=500)


@api_view(['GET'])
def get_user_data(user_id):
    ref = db.reference(f'users/{user_id}')
    return ref.get()