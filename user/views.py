import json
from django.http import JsonResponse, HttpResponseBadRequest
from Investa.utils import send_otp_email, upload_video_to_drive, send_password_reset_email_custom, upload_image_to_drive, get_or_create_drive_folder
from django.core.cache import cache
from firebase_admin import auth, db
from rest_framework.response import Response
from rest_framework.decorators import api_view, parser_classes, permission_classes
from rest_framework.parsers import MultiPartParser, FormParser
import os
import uuid
from rest_framework import status
from django.conf import settings
import requests
from rest_framework.views import APIView
from datetime import datetime


@api_view(['POST'])
def request_otp(request):
    """Send OTP and temporarily store user details using Firebase-generated ID."""
    try:
        data = json.loads(request.body)
        email = data.get("email")
        password = data.get("password")
        username = data.get("username")
        dob = data.get("date_of_birth")

        if not email or not password:
            return JsonResponse({"error": "Email and Password are required"}, status=400)

        # Check if email already exists
        users_ref = db.reference("users")
        existing_users = users_ref.order_by_child("email").equal_to(email).get()
        if existing_users:
            return JsonResponse({"error": "Email already exists"}, status=400)

        # Send OTP
        send_otp_email(email)

        # Generate a new Firebase user ID for temporary storage
        temp_user_ref = users_ref.push({})
        temp_user_id = temp_user_ref.key

        # Cache user details for OTP verification
        user_data = {
            "firebase_user_id": temp_user_id,
            "email": email,
            "password": password,
            "username": username,
            "date_of_birth": dob
        }
        cache.set(f"user_data_{email}", user_data, timeout=600)

        return JsonResponse({"message": "OTP sent to email"}, status=200)

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)
    
    
@api_view(['POST'])
def verify_otp(request):
    """Verify OTP and create user after successful verification (no profile picture)."""
    if request.method != "POST":
        return JsonResponse({"error": "Invalid request"}, status=405)

    try:
        if not request.content_type.startswith("multipart/form-data"):
            return JsonResponse({"error": "Request content-type must be multipart/form-data"}, status=402)

        email = request.POST.get("email")
        otp_entered = request.POST.get("otp")

        stored_otp = cache.get(email)
        if not stored_otp or stored_otp != otp_entered:
            return JsonResponse({"error": "Invalid or expired OTP"}, status=403)

        cache.delete(email)  # OTP is used, delete it

        # Retrieve stored user data
        user_data = cache.get(f"user_data_{email}")
        if not user_data:
            return JsonResponse({"error": "User data expired. Please sign up again."}, status=404)

        # Create user in Firebase Authentication
        user = auth.create_user(
            email=user_data["email"],
            password=user_data["password"],
            display_name=user_data["username"]
        )

        # Use the UID generated by Firebase Auth
        firebase_user_id = user.uid

        # Save user details in Firebase Realtime Database
        users_ref = db.reference("users")
        user_info = {
            "email": user_data["email"],
            "username": user_data["username"],
            "date_of_birth": user_data["date_of_birth"]
        }
        users_ref.child(firebase_user_id).set(user_info)

        # Clear cache
        cache.delete(f"user_data_{email}")

        return JsonResponse({
            "message": "Account created successfully",
            "user_id": firebase_user_id
        }, status=201)

    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)


@api_view(['POST'])
def sign_in(request):
    try:
        data = json.loads(request.body)
        email = data.get("email")
        password = data.get("password")

        if not email or not password:
            return JsonResponse({"message": "Email and password are required."}, status=400)

        url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={settings.FIREBASE_WEB_API_KEY}"
        payload = {
            "email": email,
            "password": password,
            "returnSecureToken": True
        }

        response = requests.post(url, json=payload)
        result = response.json()

        if "error" in result:
            error_message = result["error"]["message"]
            if error_message in ["EMAIL_NOT_FOUND", "INVALID_PASSWORD"]:
                return JsonResponse({"message": "Invalid email or password."}, status=401)
            elif error_message == "USER_DISABLED":
                return JsonResponse({"message": "Your account has been disabled."}, status=403)
            else:
                return JsonResponse({"message": "Login failed. Please try again."}, status=400)

        user_id = result["localId"]
        id_token = result["idToken"]
        refresh_token = result["refreshToken"]
        email = result["email"]

        db_url = f"{settings.FIREBASE_DB_URL}/users/{user_id}.json?auth={id_token}"
        user_response = requests.get(db_url)
        user_data = user_response.json()

        if user_data is None:
            return JsonResponse({
                "message": "Sign-in successful, but user details not found.",
                "idToken": id_token,
                "refreshToken": refresh_token,
                "user_id": user_id,
                "email": email
            })

        role = user_data.get("role")

        if not role:
            return JsonResponse({
                "message": "Sign-in successful, but user has no role assigned.",
                "user_id": user_id,
                "email": email,
                "idToken": id_token,
                "refreshToken": refresh_token
            })

        if role == "investor":
            interests = user_data.get("interests")
            if interests:
                return JsonResponse({
                    "message": "Investor has interests.",
                    "role": role,
                    "user_id": user_id,
                    "email": email,
                    "interests": interests,
                    "idToken": id_token,
                    "refreshToken": refresh_token
                })
            else:
                return JsonResponse({
                    "message": "Investor has no interests yet.",
                    "role": role,
                    "user_id": user_id,
                    "email": email,
                    "idToken": id_token,
                    "refreshToken": refresh_token
                })

        elif role == "founder":
            projects_ref = db.reference('projects')
            all_projects = projects_ref.get() or {}

            has_project = any(
                proj.get("user_id") == user_id for proj in all_projects.values()
            )

            if has_project:
                return JsonResponse({
                    "message": "Founder has project(s).",
                    "role": role,
                    "user_id": user_id,
                    "email": email,
                    "idToken": id_token,
                    "refreshToken": refresh_token
                })
            else:
                return JsonResponse({
                    "message": "Founder has no projects yet.",
                    "role": role,
                    "user_id": user_id,
                    "email": email,
                    "idToken": id_token,
                    "refreshToken": refresh_token
                })

        else:
            return JsonResponse({
                "message": f"User has unknown role: {role}",
                "role": role,
                "user_id": user_id,
                "email": email,
                "idToken": id_token,
                "refreshToken": refresh_token
            })

    except Exception as e:
        return JsonResponse({
            "message": f"An unexpected error occurred: {str(e)}"
        }, status=500)



class PersonalDataList(APIView):
    def get(self, request):
        ref = db.reference("users")
        data = ref.get()
        return Response(data if data else {}, status=status.HTTP_200_OK)

    def post(self, request):
        try:
            body = request.data
            user_id = body.get('user_id')

            if not user_id:
                return Response({'error': 'user_id is required.'}, status=status.HTTP_400_BAD_REQUEST)

            ref = db.reference("users").child(user_id)

            ref.set({
                'full_name': body.get('full_name', '').strip(),
                'national_id': body.get('national_number', '').strip(),
                'phone_number': body.get('phone_number', '').strip(),
                'birthdate': body.get('birthdate', '2000-01-01').strip(),
                'country': body.get('country', '').strip(),
                'postal_code': body.get('postal_code', '').strip(),
                'address_1': body.get('address_1', '').strip(),
                'address_2': body.get('address_2', '').strip(),
            })

            return Response({'message': 'Personal data saved.'}, status=status.HTTP_201_CREATED)

        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


class PersonalDataDetail(APIView):
    def get(self, request, user_id):
        try:
            ref = db.reference(f"users/{user_id}")
            data = ref.get()

            if not data:
                return Response({'error': 'User not found.'}, status=status.HTTP_404_NOT_FOUND)

            return Response(data, status=status.HTTP_200_OK)

        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def put(self, request, user_id):
        try:
            ref = db.reference(f"users/{user_id}")
            existing_data = ref.get()

            if not existing_data:
                return Response({'error': 'User not found.'}, status=status.HTTP_404_NOT_FOUND)

            body = request.data

            ref.update({
                'full_name': body.get('full_name', existing_data.get('full_name', '')).strip(),
                'national_id': body.get('national_number', existing_data.get('national_id', '')).strip(),
                'phone_number': body.get('phone_number', existing_data.get('phone_number', '')).strip(),
                'birthdate': body.get('birthdate', existing_data.get('birthdate', '2000-01-01')).strip(),
                'country': body.get('country', existing_data.get('country', '')).strip(),
                'postal_code': body.get('postal_code', existing_data.get('postal_code', '')).strip(),
                'address_1': body.get('address_1', existing_data.get('address_1', '')).strip(),
                'address_2': body.get('address_2', existing_data.get('address_2', '')).strip(),
            })

            return Response({'message': 'Personal data updated.'}, status=status.HTTP_200_OK)

        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def delete(self, request, user_id):
        try:
            ref = db.reference(f"users/{user_id}")
            if ref.get():
                ref.delete()
                return Response({'message': 'User data deleted.'}, status=status.HTTP_200_OK)
            else:
                return Response({'error': 'User not found.'}, status=status.HTTP_404_NOT_FOUND)

        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
def profile_details(request):
    try:
        data = json.loads(request.body.decode('utf-8'))
        user_id = data.get('user_id')

        if not user_id:
            return JsonResponse({'error': 'user_id is required.'}, status=400)

        update_data = {
            "gender": data.get('gender'),
            "employmentStatus": data.get('employment_status'),
            "primarySourceOfFund": data.get('primary_source_of_fund'),
            "monthlyIncome": data.get('monthly_income'),
            "monthlySave": data.get('monthly_save'),
            "submitted_at": datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
        update_data = {k: v for k, v in update_data.items() if v is not None}

        db.reference('users').child(user_id).child('profile_details').set(update_data)
        return JsonResponse({"message": "Profile details saved successfully."}, status=200)

    except Exception as e:
        return JsonResponse({"error": "Failed to save profile details.", "details": str(e)}, status=500)


@api_view(['POST'])
def investment_details(request):
    try:
        data = json.loads(request.body.decode('utf-8'))
        user_id = data.get('user_id')

        if not user_id:
            return Response({'error': 'user_id is required.'}, status=400)

        investment_data = {
            "investment_type": data.get('investment_term'),
            "purpose_investment": data.get('description'),
            "submitted_at": datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
        investment_data = {k: v for k, v in investment_data.items() if v is not None}

        db.reference('users').child(user_id).child('investment_details').set(investment_data)
        return Response({"message": "Investment details saved."}, status=200)

    except Exception as e:
        return Response({"error": "Failed to submit investment data.", "details": str(e)}, status=500)


@api_view(['POST'])
def upload_national_card(request):
    try:
        front_national_card = request.FILES.get('id_front_image')
        back_national_card = request.FILES.get('id_back_image')
        user_id = request.data.get('user_id')

        if not front_national_card or not back_national_card or not user_id:
            return JsonResponse({'error': 'user_id, front, and back images are required.'}, status=400)

        main_folder_id = "1nIPlwpcUGkDK0hvCfU_TlrRJyt6EmSi5"
        user_folder_id = get_or_create_drive_folder(user_id, parent_folder_id=main_folder_id)

        front_file_name = front_national_card.name
        front_image_url = upload_image_to_drive(front_national_card, front_file_name, user_folder_id)

        back_file_name = back_national_card.name
        back_image_url = upload_image_to_drive(back_national_card, back_file_name, user_folder_id)

        ref = db.reference("users").child(user_id).child("national_card")
        ref.set({
            "front_url": front_image_url,
            "back_url": back_image_url,
        })

        return JsonResponse({
            'message': 'National card uploaded.',
            'front_url': front_image_url,
            'back_url': back_image_url
        })

    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


@api_view(['POST'])
def life_picture(request):
    try:
        uploaded_file = request.FILES.get('image')
        user_id = request.data.get('user_id')

        if not uploaded_file or not user_id:
            return JsonResponse({'error': 'user_id and image are required.'}, status=400)

        file_name = f"{uuid.uuid4()}_{uploaded_file.name}"
        folder_id = "1fWzuK6MIqsKCVncaLYhV7wB6qfhDWBMd"
        image_url = upload_image_to_drive(uploaded_file, file_name, folder_id)

        ref = db.reference("users").child(user_id)
        ref.update({"profile_picture": image_url})

        return JsonResponse({'message': 'Life picture uploaded.', 'url': image_url})

    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


@api_view(['POST'])
def set_user_role(request):
    user_id = request.data.get('user_id')
    role = request.data.get('role')  # 'investor' or 'founder'

    if not user_id or not role:
        return Response({'error': 'user_id and role are required.'}, status=status.HTTP_400_BAD_REQUEST)

    if role not in ['investor', 'founder']:
        return Response({'error': 'Invalid role. Must be investor or founder.'}, status=status.HTTP_400_BAD_REQUEST)

    try:
        user_ref = db.reference(f'users/{user_id}')
        user_ref.update({'role': role})

        return Response({'message': f'Role "{role}" set for user {user_id}.'}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
def send_reset_link(request):
    email = request.data.get('email')
    if not email:
        return Response({"error": "Email is required"}, status=400)

    try:
        send_password_reset_email_custom(email)
        return Response({"message": "Reset link sent successfully"})
    except Exception as e:
        return Response({"error": str(e)}, status=500)


@api_view(['GET'])
def reset_password_with_code(request):
    oob_code = request.data.get('oob_code')
    new_password = request.data.get('new_password')

    if not oob_code or not new_password:
        return Response({"error": "Missing oob_code or password"}, status=400)

    try:
        auth.confirm_password_reset(oob_code, new_password)
        return Response({"message": "Password has been reset successfully"})
    except Exception as e:
        return Response({"error": str(e)}, status=400)


@api_view(['POST'])
@parser_classes([MultiPartParser, FormParser])
def upload_video(request):
    user_id = request.data.get('user_id')
    video = request.FILES.get('video')

    if not user_id or not video:
        return Response({'error': 'user_id and video are required.'}, status=status.HTTP_400_BAD_REQUEST)

    filename = f"{uuid.uuid4()}.mp4"
    with open(filename, 'wb+') as f:
        for chunk in video.chunks():
            f.write(chunk)

    try:
        drive_filename = f"{uuid.uuid4()}_{user_id}_reel.mp4"  # Unique filename per upload
        folder_id = settings.FOLDER_ID_FOR_REELS
        video_url = upload_video_to_drive(filename, drive_filename, folder_id)

        # Use push to add a new reel entry instead of replacing existing
        db.reference(f'reels/{user_id}').push({
            'video_url': video_url,
            'timestamp': datetime.now().isoformat()
        })

        return Response({'message': 'Video uploaded', 'video_url': video_url}, status=status.HTTP_200_OK)

    except Exception as e:
        return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    finally:
        if os.path.exists(filename):
            os.remove(filename)


@api_view(['GET'])
def get_reels(request):
    """
    Get all reels stored in Firebase Realtime Database.
    """
    try:
        reels_ref = db.reference("reels")
        reels_data = reels_ref.get()

        if not reels_data:
            return Response({"reels": []}, status=200)

        # Convert reels to a list of dicts with reel_id included
        reels_list = [
            {"reel_id": reel_id, **reel_info}
            for reel_id, reel_info in reels_data.items()
        ]

        return Response({"reels": reels_list}, status=200)

    except Exception as e:
        return Response({"error": str(e)}, status=500) 


@api_view(['POST'])
def change_password(request):
    try:
        data = request.data
        email = data.get('email')
        old_password = data.get('old_password')
        new_password = data.get('new_password')
        confirm_password = data.get('confirm_new_password')

        if not all([email, old_password, new_password, confirm_password]):
            return Response({'error': 'All fields are required.'}, status=400)

        if new_password != confirm_password:
            return Response({'error': 'New passwords do not match.'}, status=400)

        # Step 1: Sign in with email and old password
        sign_in_url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={settings.FIREBASE_API_KEY}"
        sign_in_payload = {
            "email": email,
            "password": old_password,
            "returnSecureToken": True
        }
        sign_in_response = requests.post(sign_in_url, json=sign_in_payload)

        if sign_in_response.status_code != 200:
            return Response({'error': 'Old password is incorrect.'}, status=400)

        id_token = sign_in_response.json().get('idToken')

        # Step 2: Update password
        update_url = f"https://identitytoolkit.googleapis.com/v1/accounts:update?key={settings.FIREBASE_API_KEY}"
        update_payload = {
            "idToken": id_token,
            "password": new_password,
            "returnSecureToken": True
        }
        update_response = requests.post(update_url, json=update_payload)

        if update_response.status_code == 200:
            return Response({'message': 'Password changed successfully.'}, status=200)
        else:
            return Response({'error': 'Failed to change password.'}, status=400)

    except Exception as e:
        return Response({'error': str(e)}, status=500)


@api_view(['POST'])
def change_email(request):
    try:
        data = request.data
        old_email = data.get('old_email')
        new_email = data.get('new_email')
        password = data.get('password')

        if not all([old_email, new_email, password]):
            return Response({'error': 'All fields are required.'}, status=400)

        # Step 1: Sign in with old email and password
        sign_in_url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={settings.FIREBASE_API_KEY}"
        sign_in_payload = {
            "email": old_email,
            "password": password,
            "returnSecureToken": True
        }
        sign_in_response = requests.post(sign_in_url, json=sign_in_payload)

        if sign_in_response.status_code != 200:
            return Response({'error': 'Incorrect old email or password.'}, status=400)

        id_token = sign_in_response.json().get('idToken')

        # Step 2: Change email
        update_url = f"https://identitytoolkit.googleapis.com/v1/accounts:update?key={settings.FIREBASE_API_KEY}"
        update_payload = {
            "idToken": id_token,
            "email": new_email,
            "returnSecureToken": True
        }
        update_response = requests.post(update_url, json=update_payload)

        if update_response.status_code == 200:
            return Response({'message': 'Email changed successfully.'}, status=200)
        else:
            return Response({'error': 'Failed to change email.'}, status=400)

    except Exception as e:
        return Response({'error': str(e)}, status=500)


@api_view(['POST'])
def delete_account(request):
    try:
        data = request.data
        email = data.get("email")
        password = data.get("password")
        user_id = data.get("user_id")

        if not all([email, password, user_id]):
            return Response({"error": "email, password, and user_id are required."}, status=400)

        # Step 1: Sign in to get idToken
        sign_in_url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={settings.FIREBASE_API_KEY}"
        sign_in_payload = {
            "email": email,
            "password": password,
            "returnSecureToken": True
        }
        sign_in_response = requests.post(sign_in_url, json=sign_in_payload)

        if sign_in_response.status_code != 200:
            return Response({"error": "Authentication failed. Check email or password."}, status=401)

        id_token = sign_in_response.json().get("idToken")

        # Step 2: Delete from Firebase Authentication
        delete_auth_url = f"https://identitytoolkit.googleapis.com/v1/accounts:delete?key={settings.FIREBASE_API_KEY}"
        delete_auth_response = requests.post(delete_auth_url, json={"idToken": id_token})

        if delete_auth_response.status_code != 200:
            return Response({"error": "Failed to delete from Firebase Auth."}, status=400)

        # Step 3: Delete all associated nodes in Realtime Database
        paths_to_delete = [
            f"users/{user_id}",
            f"saved_projects/{user_id}",
            f"invested_projects/{user_id}", 
            f"projects/{user_id}", 
            f"reels/{user_id}"  
        ]

        for path in paths_to_delete:
            db.reference(path).delete()

        return Response({"message": "User account and all related data deleted successfully."}, status=200)

    except Exception as e:
        return Response({"error": str(e)}, status=500)


@api_view(['GET'])
def get_user_data(user_id):
    ref = db.reference(f'users/{user_id}')
    return ref.get()